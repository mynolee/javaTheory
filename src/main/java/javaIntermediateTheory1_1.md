# 자바 중급 강의 1_1

## 1. Object 클래스

- 모든 클래스의 최상위 부모 클래스(= 모든 클래스가 다 상속)
- 공통 기능 제공, 다형성의 기본 구현

### 제공하는 기능

- 객체의 정보를 제공하는 toString()
- 객체의 같음을 비교하는 equals()
- 객체의 클래스 정보를 제공하는 getClass()
- 객체를 식별하는 해시값 반환하는 hashCode()
- 기타 여러가지 기능

### 다형성의 기본 구현

- 모든 객체 참조 가능 -- 부모는 자식을 담을 수 있다.
- 타입이 다른 객체들을 Object에 보관 가능(ex.배열)

toString()
- 객체의 정보를 문자열 형태로 제공

### 동일성, 동등성
- 동일성(Identity) : (메모리 주소값) ==연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인.
- 동등성(Equality) : (값) .equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인.
- "동일"은 완전히 같음을 의미. "동등"은 같은 가치나 수준을 의미, 형태나 외관 등이 완전히 같지 않을 수 있다.
- 동일성 = 물리적으로 같은 메모리에 있는 객체 인스턴스인지 참조값 확인
- 동등성 = 논리적으로 같은지 확인.
- Object클래스는 equals()메서드를 ==으로 동일성 비교 제공
- 동등성 비교는 equals() 메서드 재정의해야.


## 2. 불변 객체(Immutable Object) -- 매우 중요

왜?
- 기본형 변수는 같은 값을 공유하지 않는다.(10,10이면 서로 다른 숫자 10 두개가 있는거)
- 참조형 변수는 참조값을 통해 같은 객체(인스턴스) 공유 가능 --> **_공유된 객체의 값 변경시 사이드 이펙트_**
- 객체의 공유 참조를 막을 방법은 없다. --> 서로 다른 객체를 참조하면 사이드 이펙트 해결.

정의
: 객체의 상태(객체 내부의 값, 필드, 멤버 변수)가 변하지 않는 객체

- 값 변경 x --> 사이드 이펙트 원천 차단
- 값을 변경하고 싶으면 변경하고 싶은 값으로 새로운 불변 객체 생성해야.
--> 불변 객체에서 변경과 관련된 메서드들은 보통 객체를 새로 만들어서 반환. 꼭! 반환값을 받아야.

### String 클래스가 불변 객체(Integer, LocalDate 등등)

모든 클래스를 불변으로 만드는 것은 아니다.

클래스를 불변으로 설계하는 다른 이유
- 캐시 안정성
- 멀티 쓰레드 안정성
- 엔티티의 값 타입

 
## 3. String 클래스

- String은 클래스, 참조형, 내부는 char[] {자바 9부터 char[]대신에 byte[]사용}
- 참조형이지만 너무 자주 다루므로 java 언어에서 편의상  +연산 제공
- 비교시 ==비교가 아니라 equals()비교 --문자열 풀(String Pool)(힙 영역 사용)
- 불변 객체 --> 문자열 변경시 새로운 String 객체 반환
- 메서드 --문자열 정보조회, 비교, 검색, 조작 및 변환, 분할 및 조합 등등

### StringBuilder -가변 String
왜?
- 불변인 String클래스의 단점은 변경이 많은 상황에서 매 변경시 객체를 생성해야 --> 자원 낭비
- 가변 String인 StringBuilder --사이드 이펙트 주의
- StringBuilder 직접 사용도 가능

### StringBuilder vs StringBuffer

- StringBuilder : 멀티 쓰레드 상황에 안전x , 동기회 오버헤드x --> 속도 빠름.
- StringBuffer : 내부에 동기화, 멀티 스레드 상황에 안전, 동기화 오버헤드 --> 성능 느림.

### 메서드 체이닝(Method Chaining)

- 자기 자신의 참조값 반환 후 .찍어서 자신의 메서드 호출
- .찍어서 변수명 생략 가능
- 코드를 간결하고 읽기 쉽게 만들어줌.


## 4. 래퍼, Class 클래스

### 레퍼
기본형 타입의 한계
- 객체가 아님.
- null 값을 가질 수 없음. 항상 값을 가져야함.

래퍼 클래스(Wrapper Class)
- 기본형의 객체 버전.
- 불변이다.
- equals로 비교해야 한다.

박싱(Boxing)
- 기본형을 래퍼 클래스로 변경하는 것

언박싱(Unboxing)
- 래퍼 클래스에 들어있는 기본형 값을 다시 꺼내는 메서드

비교는 equals() 사용

기본 클래스 vs 래퍼 클래스
- 기본형 연산이 래퍼 클래스보다 대략 5배 정도 빠르다.
- 기본형은 메모리에서 단순히 그 크기만큼의 공간을 차지.
- 래퍼 클래스의 인스턴스는 내부에 필드로 가지고 있는 기본형의 값 뿐만 아니라 자바에서 객체 자체를 다루는데 필요한 객체 메타데이터를 포함하므로 더 많은 메모리(8~16바이트) 추가 사용.

유지보수 vs 최적화
- 유지보수하기 좋은 코드를 먼저 고민해야.

### Class 클래스

주 기능 : 타입 정보 얻기, 리플렉션, 동적 로딩과 생성, 애노테이션 처리

Class 클래스에는 클래스의 모든 정보 포함.
이 정보 기반으로 인스턴스 생성, 메서드 호출, 필드 값 변경 가능.

리플렉션
- Class 사용하여 클래스의 메타 정보를 기반으로 클래스에 정의된 메서드, 필드, 생성자 등 조회
- 이를 통해 객체 인스턴스를 생성하거나 메서드를 호출하는 작업 가능.

System, Math, Random 클래스


## 5. 열거형 - ENUM

String 사용시 문제점
- 타입 안정성 부족 - 오타 발생 쉬움, 유효하지 않은 값 입력 가능
- 데이터 일관성
- 문자열 상수화 --> 근본 해결 x

### 타입 안전 열거형 패턴 - Type-Safe Enum Pattern
- private 생성자 사용
- 타입 안정성 향상
- 데이터 일관성
- 제한된 인스턴스 생성
- 단점으로는 구현시 유의점 및 많은 코드 작성해야

### 열거형 - ENUM Type

- 열거형도 클래스
- 열거형은 자동으로 java.lang.Enum을 상속 받는다.
- 외부에서 임의로 생성 불가.
- toString() 재정의 --> 참조값 직접 확인 x.
- 열거형은 switch 문에 사용 가능.
- 타입 안정성 향상
- 간결성 및 일관성
- 확장성


## 6. 날짜와 시간

- 타임존 계산
- 모든 날짜 클래스는 불변. 변경이 발생하는 경우 새로운 객체를 생성해서 반환하므로 반환값 꼭 받아야.

isEqual() vs equals()
- isEqual() : 단순 비교대상이 시간적으로 동일시 true 반환.
- equals() 객체의 타입, 타임존 등등 내부 데이터의 모든 구성요소가 같아야 true 반환.

기계 중심의 시간 - Instant
- Instant 내부에는 초 데이터만 들어있다.(나노초 포함)

기간, 시간의 간격 - Duration, Period

- 특정 시점의 시간(간격)
- 시간의 간격 (기간)

시간의 단위 - TemporalUnit, ChronoUnit
TemporalUnit - 날짜와 시간을 측정하는 단위 나타냄.
ChronoUnit - 다양한 시간 단위 제공.

시간 필드 - ChronoField
- 날짜와 시간의 특정 부분을 나타내는 열거형

날짜와 시간 문자열 파싱과 포맷팅
- 포맷팅 : 날짜와 시간 데이터를 원하는 포맷의 문자열로 변경하는 것 ( Data -> String)
- 파싱 : 문자열을 날짜와 시간 데이터로 변경하는 것(String -> Data)

