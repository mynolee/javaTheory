# 자바 중급 강의 2_2


## 3. 컬렉션 프레임워크 - ArrayList

- 크기가 가변적인 배열을 구현한 클래스.
- 내부적으로 배열(Object[] 사용)
- 인덱스 순서 유지
- get(index)는 빠름(O(1))  -->> 조회 중심
- 중간 삽입/삭제는 느림 (O(n))
- 멀티스레드 환경에서는 비동기(직접 동기화 필요)
- 용량이 부족하면 배열 크기 * 1.5로 자동 확장
- 요소를 삭제하면 뒤의 요소들을 모두 왼쪽으로 한 칸씩 이동


## 4. 컬렉션 프레임워크 - LinkedList

- 노드(Node) 구조로 이루어진 자료 연결 리스트. 노드(Node)를 연결.
- 각 노드는 데이터와 다음/이전 노드에 대한 참조(주소) 저장.
- 인덱스 순서 유지
- get(index)는 느림 (O(n))
- 처음/끝/중간 삽입.삭제 빠름 (O(1) / 위치를 찾는 데는 O(n))    --> 삽입/삭제 중심
- 양방향 이동 가능 (앞/뒤 노드 추적 가능)
- 멀티스레드 환경에서는 비동기
- 리스트의 앞/뒤에서 데이터를 자주 추가/삭제 시 사용
- Queue, Deque처럼 FIFO/LIFO 구조로 사용할 때


## 5. 컬렉션 프레임워크 - List

- 순서가 있는 데이터 집합을 다루기 위한 컬렉션 인터페이스
- 중복 허용, 인덱스 기반 요소 접근 가능.
- 구현 클래스로는 ArrayList, LinkedList 등이 있음
- List는 ArrayList, LinkedList 등의 공통된 동작 규약(interface)을 정의.
- 인터페이스로 선언하고 구현체는 상황에 맞게 선택

인터페이스
- "이렇게 동작하겠다"는 약속(규약)을 정한 룰.
- 인터페이스는 메서드 이름과 구조만 정의해 놓고, 실제 동작(구현)은 나중에 구현 클래스가 책임짐.

왜 List(= 인터페이스)랑 ArrayList, LinkedList(= 구현 클래스)등등 이랑 나누냐?
- 프로그래머는 인터페이스(약속)만 보고 프로그래밍하고, 나중에 구현체는 쉽게 바꿀 수 있도록 하기 위해서.
- 나중에 구현체를 쉽게 바꾸고, 코드 재사용성과 유연성 확보를 위해.

예시)
인터페이스 List = 콘센드 규격 (220v, 2구짜리)
ArrayList, LinkedList 는 콘센트에 꽂을 수 있는 실제 기기(선풍기, 전기장판 등)
콘센트 규격만 맞으면 어떤 기기도 꽂을수 있듯이 인터페이스도 마찬가지로 구현체를 바꾸어도 같은 규칙만 따르면 됨.


## 6. 컬렉션 프레임워크 - Hash

- 어떤 데이터를 고정된 크기의 숫자(또는 문자열)로 바꿔주는 함수나 방법.
- 빠르게 검색/삽입/삭제
- "홍길동" -> 그냥 리스트 O(n), 해시 -> O(1)
- 해시 = 해시 함수 + 버킷(bucket : 분산 저장 장소)(배열처럼 생김. 해시값을 배열 인덱스로 삼음.)
- 해시 충돌 : 해시값이 같아지는 경우. => 체이닝 방식으로 충돌 처리.
- HashMap, HashSet, 해시테이블 등 사용.