# 자바 중급 강의 2_4

## 9. 컬렉션 프레임워크 - Map, Stack, Queue

Map
- 키(key)와 값(value)의 쌍으로 데이터를 저장하는 자료구조 => "이름표 붙인 배열"
- key : 중복 x  / value : 중복 o   // 중복 키 입력시 값을 덮어씀
- 검색 속도 : 일반적으로 키 기준으로 매우 빠름 (Hash 기반이면 평균 O(1))
- HashMap : 순서 x / null 허용 : key o, value o / 가장 일반적인 Map
- LinkedHashMap : 입력 순서 유지 / null 허용 : key o, value o / 순서 유지 필요시 사용
- TreeMap : 키 기준 정렬 / null 허용 : key x, value o / 자동 정렬(Map에 정렬 필요시 사용)
- HashTable : 정렬 x / null x / 동기화 지원
- key를 넣으면 hashCode() -> 배열의 인덱스 계산
- 같은 해시값에 여러 키가 충돌하면 LinkedList나 Tree로 연결
- Map이 자주 사용되는 상황 : 이름-전화번호(전화번호부) / 학생-성적(점수표) / 상품-가격(재고관리) / 그래프에서 인접 리스트 표현
- Set은 내부적으로 Map을 사용해 구현됨 / Set은 오직 key만 있는 Map

Stack
- LIFO(Last In, Fisrt Out) - 마지막에 들어간 데이터가 가장 먼저 나오는 구조
- push, pop(스택 맨 위의 데이터 제거+반환), peek(맨 위의 데이터 확인(제거x)), isEmpty
- 배열 기반 스택 - 고정된 크기의 배열 이용, 인덱스를 통해 top 위치 관리 / 단점 : 크기 제한있어 overflow 가능
- 연결 리스트 기반 스택 - Node로 연결된 구조, 각 노드가 이전 노드를 가리킴(top노드만 알면됨) / 장점 : 크기 제한 x, 동적 확장 가능
- 재귀 함수, 괄호 검사, 웹 브라우저 뒤로 가기, DFS, 후위표기 계산기

Queue
- 선형 자료구조, FIFO(First In, First Out) - 먼저 들어온 데이터가 먼저 나가는 구조
- 입구와 출구 다름 / enqueue : 뒤에서 삽입(offer,add) / dequeue : 앞에서 삭제(poll, remove)
- enqueue, offer() - 데이터 큐 뒤쪽에 삽입
- dequeue, poll() - 앞쪽 데이터 삭제하고 반환
- peek(), element() - 삭제하지 않고 앞쪽 데이터 반환
- isEmpty()
- 배열 기반 Queue - 고정 크기의 배열로 구현 / front,rear 인덱스를 따로 관리 / 단점 : 앞쪽 공간 재사용 못함 -> 비효율
- 원형 Queue - 배열 끝에 도달하면 처음으로 돌아가도록 구성 / 장점 : 공간을 효율적으로 재사용
- 연결 리스트 기반 Queue - Node 연결방식으로 구현 / front, rear 포인터만 알면됨 / 장점 : 크기제한 없음, 동적 메모리 사용
- 사용 예시
    - 운영체제 : 작업 스케줄링
    - 자료구조 : BFS
    - 웹 서버 : 요청 처리 대기열
    - 게임 : 이벤트 처리, 플레이어 순서 저장
    - 네트워크 : 패킷 전송 순서 보장

## 10. 순회, 정렬

순회
- 데이터를 차례차례 접근해서 어떤 작업을 수행 하는것
- 배열/리스트 순회, 트리 순회, 그래프 순회
- 목적 : 데이터 전부 읽기, 탐색, 검색, 연산 수행, 정렬을 위한 준비, 구조 분석

정렬
- 데이터를 일정한 기준에 따라 순서대로 재배열하는 것
- 데이터를 보기 좋게 정리
- 이진 탐색 등을 사용하기 위한 전처리
- 중복 제거, 통계, 최댓값 최솟값 췹게 찾기
