# 자바 중급 부족한 부분_ 20250623

## 생성자

생성자는 메서드.
" 초기화 블록이 먼저 실행되고 생성자가 실행 "
생성자(Constructor)
- 객체가 생성될 때 호출되어, 인스턴스 변수를 초기화하는 특수한 메서드.
- 클래스 이름과 같아야 함.
- 반환 타입이 없음(void도 안씀)
- 객체를 만들 때 자동으로 실행됨.
- 매개변수를 받아 다양한 초기화 가능

초기화 블록
- 객체가 생성될 때 모든 생성자보다 먼저 자동으로 실행되는 블록.
- {}안에 초기화 코드만 작성하며, 생성자보다 먼저 실행.
- 인스턴스 초기화 블록 : 객체 생성 시 실행.
- 정적 초기화 블록 : 클래스가 처음 로딩될 때 단 1번만 실행.


## 클래스와 객체 차이

클래스랑 객체 제대로 구분.
- 클래스 : 객체를 만들기 위한 설계도
- 속성(필드)과 행동(메서드)을 정의한 틀.
- 설계도를 바탕으로 만들어진 실제 집은 "객체"
- 객체 : 클래스를 기반으로 생성된 실체(instance)
- 클래스의 구조를 바탕으로 메모리에 생성된 데이터 덩어리.
- 객체는 "실제로 존재"하는 것. -- 메모리에 할당됨.
- 각 객체는 클래스에서 정의한 속성과 행동을 자신만의 데이터로 가짐.

## 절차지향과 객체지향의 차이

절차지향 : "순서대로 작업을 수행"하는 방식. 컴퓨터 프로그램을 명령어의 목록으로.
- 문제를 "순차적인 절차(로직, 순서)"로 해결하는 방식.
- "**무엇**을 먼저하고, 그 다음 **무엇**을 한다"는 흐름이 중심.
- 코드가 위에서 아래로 흐름 중심
- 함수를 통해 작업 단위로 분리
- 데이터와 함수가 분리

객체지향 : "객체를 중심으로 프로그램을 구성"하는 방식. "객체"들의 모임으로 파악.
- "데이터(상태)" 와 이를 처리하는 "함수(행동)"를 하나의 객체로 묶어 **어떻게** 문제를 해결하는 방식.
- "현실 세계를 프로그램으로 표현하는 방식"
- 현실 세계의 "사물(객체)"을 모델링
- 객체는 "속성(필드)"과 "행동(메서드)"을 가짐
- 재사용성, 캡슐화, 상속, 다형성

절차지향에서의 함수 vs 객체지향에서의 객체

절차지향(함수 기반)
- 데이터는 따로, 함수는 외부
- 데이터 조작은 외부에서 직접
- "**무엇**을 할까"에 집중

객체지향(객체 기반)
- 데이터와 함수가 하나의 단위로 묶임(객체)
- 객체 내부 메서드만 데이터 접근 허용
- "**누가** 책임질까"에 집중

## 해시 코드(hashCode) & 동일성, 동등성

hashCode()

- "객체를 식별할 수 있는 정수값(int)"을 반환하는 해시 함수
- equals()와 함께 주로 HashMap, HashSet 같은 자료구조에서 사용.
- 객체를 빠르게 찾기 위한 키.
- 해시 기반 자료구조의 버킷(bucket)을 결정하는 데 활용.

해시코드는 객체의 "주소"가 아니고, 같을 수 있음.

- 정확히는 객체의 메모리 주소가 아님. **객체의 상태를 바탕으로 계산된 정수값.**
- JVM 구현에 따라 기본적으로 겍체의 메모리 주소를 바탕으로 계산된 값을 반환할 수 있으나, 이는 Object 클래스의 기본 구현.
- 우리가 equals()를 오버라이딩하면 hashCode()도 같이 오버라이딩 됨.
- 서로 다른 객체라도 hashCode() 값이 같을 수 있음.(해시 충돌(hash collision))
- equals()가 true면 hashCode()도 같아야 함. 하지만 **hashCode()가 같다고 해서 equals()가 true일 필요는 없음.**

동일성 vs 동등성

동일성(Identity)
- 두 객체가 완전히 같은 객체인가 ==> **메모리 주소가 같은가?**
- 자바에서 == 연산자로 비교.
- 같은 객체 인스턴스를 참조하고 있는지 확인.

동등성(Equality)
- 두 객체의 내용이 같은가 ==> **값이나 상태가 같은가?**
- 자바에서 .equals() 메서드로 비교.
- 각 객체의 의미적 동등함을 비교 (내용 중심)

근데 왜 hashCode랑 equals를 같이 써야하나? hashCode의 값에 대한건 동일성으로 사용해야하는 것 아닌가?
- hashCode()는 equals()와 함께 "동등성"을 기반으로 해시 기반 컬렉션(HashMap, HashSet)이 잘 작동하도록 하는 도구.

HashMap, HashSet 등의 내부적으로 동작 순서
- 1. 객체의 hashCode() 값을 구해서 버킷(bucket)을 찾고
- 2. 그 안에서 equals()로 정확히 같은 객체인지 비교.

hashCode() : 먼저 빠르게 버킷을 결정(성능 목적)
equals() : 버킷 안에서 진짜 같은지 확인함(논리적 동등 비교)

hashCode와 equals는 **반드시 같다고 판단되는 객체(equals == true)는 hashCode()도 반드시 같아야 한다.**
그렇지 않으면 HashMap, HashSet 제대로 작동 x
**"논리적으로 같은 객체" 는 동일한 hashCode를 가져야 함.**

그렇다면 hashCode값이 같으면 동일성을 가지나?
**아님!**
- 해시코드가 같아도 해시코드 충돌 가능성 존재 ==> 동일하거나 동등하다는 보장 없음!
왜 hashCode가 같아도 동일하지 않은가?
- hashCode()는 단지 객체의 내용을 바탕으로 계산된 정수값
- 자바에서는 다른 객체라도 우연히 같은 hashCode를 가질 수 있음 ==> 해시 충돌

hashCode값이 같으면 동일한 객체 x
- 메모리 주소와는 무관하며, 충돌 가능성 o
같은 hashCode면 equals도 true?
- 반드시 그런거 아님.
hashCode와 equals는 반드시 같이 오버라이딩 해야.


## StringBuilder와 buffer 차이

둘 다 Java에서 문자열을 수정 가능한(mutable)한 형태로 다룰 수 있게 해주는 클래스.
하지만 **동기화(synchronization)** 여부 차이 존재.

StringBuilder
- 비동기(Thread-safe 아님)
- 빠름(단일 쓰레드 환경에 적함)

StringBuffer
- 동기화 지원(Thread-safe)
- 느림(동기화로 인한 오버헤드)
- 멀티 스레드 환경

스레드
- 하나의 프로그램(프로세스)안에서 실행되는 작은 작업 단위.

멀티 스레드
- 여러 개의 스레드가 동시에 작업을 수행하는 것.
- ex) 유튜브 앱에서 동영상 재생, 자막 출력, 사용자 입력 감지, 네트워크로 영상 스트리밍 등등 동시에 작동.

동기화(synchronization)
- 여러 스레드가 하나의 공유 자원(변수, 객체 등)을 동시에 접근할 때, 충돌 없이 순서대로 처리되도록 막는 것
- 멀티스레드 환경에서 데이터의 일관성을 유지하기 위해
- 공유 자원을 동시에 건드리지 못하게 **잠그는(lock)** 작업.
- 데이터 무결성 유지.
- 속도가 느려질 수 있음(대기 때문에)

멀티 스레드 환경에서는 동기화를 하지 않으면 값이 꼬이거나 충돌 발생.
동기화는 데이터를 안전하게 하지만, 성능 저하를 가져올 수 있음.

StringBuffer 동기화됨 -> 안전하지만 느림.
StringBuilder 동기화 안됨. -> 빠르지만 위험.


## 박싱(Boxing), 언박싱(Unboxing)

기본형과 참조형간의 변환.

박싱(Boxing)
- 기본형 -> 참조형으로 변환.
- 객체 필요 시(ex. 컬렉션)

언방식(Unboxing)
- 참조형 -> 기본형으로 변환
- 기본 연산 시

왜 필요한가?
- 자바의 컬렉션(List, Set, Map)등은 기본형으로 직접 저장 x. 객체(참조형)만 저장 가능.
- 박싱해서 객체로 저장

## enum

- 열거형 타입(enumerated type)을 정의시 사용하는 키워드
- 서로 연관된 상수들을 하나의 타입으로 묶어서 표현할 수 있게 해줌.
- 상수의 집합을 표현하는 특별한 클래스.
- 타입 안정성 : 잘못된 값 사용 방지
- 코드 가독성 : 의미 있는 이름으로 코드가 명확해짐.
- 기능 확장 : 변수, 메서드 정의 가능(클래스처럼 사용)
- 비교 가능 : ==, switch로 비교 가능(문자열보다 안전)
- 메서드와 필드 추가도 가능.
- 단순 상수 집합을 넘어서 객체처럼 동작 가능.


## 날짜 클래스 -- LocalDateTime, ZonedDateTime

- 우리나라 시간 = 그리니치천문 기준 +9

localDateTime
- 시간대 없이 날짜와 시간을 나타내는 클래스
- 단순한 날짜와 시간 정보만 담고 있음.
- 시간대 고려하지 않기 때문에 전 세계 어디서든 같은 값.
- 내부 시간 계산, DB 저장 등.

zonedDateTime
- 시간대(TimeZone) 정보를 포함하는 날짜와 시간 클래스
- +09:00, [Asia/Seoul] 같은 시간대 정보가 포함됌.
- 국제화된 서비스에서 시간대 변환 필요시 필수.

localDateTime, zonedDateTime 둘 다 불변 객체.
내부 값을 절대 변경하지 않고, 변경하는 것처럼 보여도 항상 새 객체 반환.
- 스레드 안전(Thread-safe) : 여러 스레드가 공유해도 안전
- 예측 가능 : 원본이 바뀌지 않으니 side effect 없음.
- 함수형 프로그래밍 철학과 잘 어울림.

Date 와 Calender의 주요 문제점

- 설계가 불완전하고 직관적이지 않음. // Date는 월을 0부터 시작. Calender는 요일이 숫자로 표현.
- 불변성 없음.(mutable) // 값이 언제든지 바뀔수 있음. ==> 멀티스레드 환경에서 매우 위험하고 예측 불가능.
- 스레드 안전하지 않음(Thread-unsafe) // 공유 시 동기화 필요 --> 실수로 공유하면 데이터 꼬임 발생.
- API가 일관성 없고 사용이 불편.

그래서 Java8부터 나온 것이 java.time
LocalDate, LocalDateTime, ZonedDateTime, Instant 등
- 불변(immutable)
- 명확한 API
- 체이닝 가능
- 시간대 명확히 처리 가능
- 스레드 안전

체이닝(Chaining)
- 메서드를 줄줄이 연결해서 호출하는 것
- 객체의 메서드가 자기 자신(this)을 반환하거나, 다른 객체를 반환해서 메서드를 연속적으로 호출할 수 있게 하는 방식
- 가독성, 코드 간결(중간 변수 줄임.)

**재귀함수도 체이닝인가?**
- 재귀함수는 체이닝과 다르다.

재귀 함수
- 함수가 자기 자신을 다시 호출하는 함수
- 어떤 작업을 다시 나 자신에게 맡기는 것

메서드 체이닝(Method Chaining)
- 여러 개의 메서드를 줄줄이 연결해서 호출하는 것
- 하나의 결과를 다음 작업으로 넘기는 것

**그럼 return this 체이닝은 재귀함수가 아닌가?**
- 아님!
- 체이닝은 자기 자신을 반환하지만, 자기자신을 호출하지는 않음. 호출 스택이 생기지도 않고 반복 흐름도 없음.
- 함수 내부에서 자기 자신을 호출하는 것이 진짜 재귀.
- 재귀 호출 스택이 쌓일수록 재귀 깊이 증가 -> 스택 메모리 사용 증가


## 익명 클래스

- 이름이 없는 클래스 => 한 번만 사용할 클래스 간단히 정의 시 자주 사용 // 인터페이스나 추상 클래스 구현 시 많이 사용.
- 즉시 객체로 생성하는 클래스
- 콜백 함수, 스레드 실행, 간단한 일회성 구현(클래스 정의 필요 x => 코드 간결화)
- 재사용 불가, 코드 길어지면 가독성 -
- 중복되면 사용 어렵고 유지보수 힘듦.
- Java8부터 람다로 대체됨.(특히 함수형 인터페이스)
- 주 용도 : 인터페이스 / 추상 클래스의 간단한 일회성 구현

## 내부 클래스(inner class) 와 중첩 클래스(nested class) 와 지역 클래스(Local Class)

둘 다 모두 클래스 안에 정의된 클래스

중첩 클래스 (Nested Class)
- 어떤 클래스 안에 정의된 모든 클래스

내부 클래스 (Inner Class)
- 그 중에서도 인스턴스 내부 클래스만을 지칭

중첩 클래스 = 내부 클래스 + static 중첩 클래스

중첩 클래스 4 종류
- 인스턴스 내부 클래스 : 클래스 안의 일반 클래스
- Static 중첩 클래스 : 클래스 안의 static 클래스 / 외부 인스턴스 접근 불가
- 지역 클래스 : 메서드 내부에 선언된 클래스 / 지역변수 캡쳐 주의
- 익명 클래스 : 이름 없이 일회성으로 정의

인스턴스 내부 클래스
- 외부 클래스의 인스턴스 변수에 접근 가능
- static 멤버 가질 수 x.

정적(Static) 중첩 클래스
- 외부 클래스의 인스턴스 없이 사용 가능.
- 외부 클래스의 인스턴스 변수에는 접근 불가.

지역 클래스(Local Class)
- 메서드 내부에 정의됨.
- 로컬 변수는 final 혹은 effectively final 일 때만 접근 가능.

익명 클래스(Anonymous Class)
- 이름이 없음.
- 인터페이스나 추상 클래스 즉석 구현
- 한 번만 사용 시

중첩 클래스
- 클래스 안에 정의된 클래스 전체를 의미

내부 클래스
- 그 중에서도 인스턴스 내부 클래스만 지칭

## 지역 클래스, 지역 변수, 지역 변수 캡쳐

지역 변수(Local Variable)
- 메서드, 생성자, 블록 내부에서 선언된 일시적인 변수
- 해당 블록 내에서만 유효
- 메서드가 끝나면 사라짐
- 지역 변수는 final 혹은 effectively final이어야 외부클래스에서 접근 가능.

지역 클래스(Local Class)
- 메서드 안에 정의된 클래스
- 선언된 블록 내부에서만 사용 가능
- 메서드 안에 있기 때문에 외부에서는 사용 x.
- 사용 예시 : 이벤트 핸들러, 임시 작업 객체 등

지역 변수 캠쳐(Variable Capture)
- 지역 클래스(또는 익명 클래스)에서 바깥 지역 변수에 접근 시, 그 변수는 final 혹은 effectively final 이어야 한다.

캡쳐란?
- 내부 클래스가 지역 변수의 복사본을 가짐.
- 지역 변수는 스택에 존재, 지역 클래스는 힙에 존재.
- 스택은 메서드 종료 시 사라지므로 값 복사를 위해 final 필요.

왜 final?
- 내부 클래스가 참조하는 지역 변수는 변하지 않아야함.
- 지역 클래스 안에서 접근하는 지역 변수는 반드시 final 또는 final처럼 한 번만 초기화 되어야함.

지역 변수
- 메서드 안에서 선언되는 변수

지역 클래스
- 메서드 안에 선언된 클래스

지역 변수 캡쳐
- 내부 클래스가 지역 변수를 참조하는 행위


## 깊은 복사, 얕은 복사

참조를 같이 복사하느냐, 실제 내용까지 복사하느냐의 차이.

얕은 복사(Shallow Copy)
- 객체의 참조값만 복사함 -> 내용은 공유
- 같은 주소 객체를 가리킴.

깊은 복사(Deep Copy)
- 객체 안의 필드들도 새로 복사함 -> 완전히 독립된 복제본


얕은 복사 : 같은 객체를 가리키는 참조만 복사(주소 공유)
깊은 복사 : 내부까지 모두 새로운 객체로 복사(완전 독립)
복사 생성자나 clone() 오버라이딩으로 깊은 복사 구현 가능


## finally

예외 처리 구문에서 항상 실행되는 블록.
- 예외가 발생하든 안 하든, 무조건 실행된다는 특징.
- 주로 자원 정리(파일 닫기, DB 연결 종료 등)에 사용.
- 파일 입출력 -> 파일 닫기
- DB 연결 -> 커넥션 정리
- 네트워크 -> 소켓 닫기
- 임시 리소스 해제 -> 자원 누수 방지
- finally 블록에서 예외를 또 발생시키면 원래 예외를 덮을 수 있음 ->> 주의 필요
- System.exit(0) 같은 강제 종료는 finally 실행하지 않음
- return 문과 함께 써도 실행됨.

## unchecked, checked 예외처리

예외는 두 종류.
unchecked, checked 예외처리
- 컴파일러가 강제하는지 여부에 따라 구분.

예외(Exception)
- 프로그램 실행 중 에러가 발생했을 때 이를 처리하기 위한 객체

Checked Exception(체크 예외)
- 컴파일러가 예외 처리를 강제하는 예외
- 예외 처리 필수
    - try-catch 또는 throws로 처리하지 않으면 컴파일러 에러
    - IOException, SQLException, FileNotFoundException 등
    - 외부 자원(파일, 네트워크, DB 등) 다룰 때 자주 발생.
- 개발자가 사전에 처리해야 함.

Unchecked Exception(언체크 예외)
- 컴파일러가 예외 처리를 강제하지 않는 예외(런타임 예외라고도 불림.)
- 예외 처리 필수가 아님.
    - try-catch 안해도 컴파일 에러 x.
    - NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException, ArithmeticException 등
    - 주로 프로그래머 실수, 논리 오류 등 내부 로직 문제.
- 발생하면 런타임 중 터짐.

외부 자원 접근(파일, DB, 네트워크) --> Checked
내부 코드 오류(null, 잘못된 인자 등) --> Unchecked


## 예외(Exception) 와 오류(Error) 차이 

둘 다 실행 중 발생할 수 있는 비정상 상황.
의미와 처리 방법이 완전 다름.

예외(Exception)
- 프로그램 실행 중 발생할 수 있는 비정상 상황 중, 개발자가 처리 가능한 것
- NullPointerException : null 값을 참조 시
- IOException : 파일을 못 찾거나 읽을 수 없을 떄
- ArithmericException : 0으로 나눴을 때

오류(Error)
- JVM이나 시스템 레벨의 심각한 문제(개발자가 예외처리로 대응 x.)
- OutofMemoryError : 메모리 부족
- StackOverflowError : 재귀 무한 호출 등으로 스택 오버플로
- InternalError : JVM 내부에서 발생한 예기치 못한 에러
- 대응하지 않음.(종료 예상)



